<?xml version="1.0" encoding="UTF-8"?>
<chapter xml:id="recursion-in-java">
    <title>Recursion in Java</title>
    <introduction>
    </introduction>

<section xml:id="basic-recursion">
        <title>Basic Recursion</title>
        <p>
            In this chapter, we will explore how to translate your recursive logic from Python to Java. While the core concepts of recursion remain the same, the syntax and structure of your code will change somewhat.
        </p>
        <p><idx>recursion</idx>
            As you may know from Python, <term>recursion</term> is a powerful problem-solving technique involving base cases and recursive steps in which a function or method calls itself. When moving to Java, the core logic you've learned remains identical. The challenge is adapting that logic to Java's statically-typed, class-based syntax.
        </p>
        <p>
            Let's take the familiar factorial function (which calculates the factorial of a number, namely the product of all positive integers from 1 to n). The logical steps in the code are the same, but the implementation details change.
        </p>
        <p>
            Here is a Python implementation using functions:
        </p>
        <program interactive="activecode" language="python">
            <code>
def factorial(n):
    # Check for negative numbers
    if n &lt; 0:
        print("Factorials are only defined on non-negative integers.")
        return
    # Base Case: 0! or 1! is 1
    if n &lt;= 1:
        return 1
    # Recursive Step: n * (n-1)!
    return n * factorial(n - 1)

def main():
    number = 5
    print(str(number) + "! is " + str(factorial(number)))

main()
            </code>
        </program>
        
        <p>
            Many Python programs organize related functions into classes. The same factorial function can be placed inside a class as a method. Then you need to create an instance of the class to call the method. There we create the class <c>MathTools</c> with a method <c>factorial</c>, and we call it from the <c>main</c> function.
        </p>
        <program interactive="activecode" language="python">
            <code>
class MathTools:
    def factorial(self, n):
        # Check for negative numbers
        if n &lt; 0:
            print("Factorials are only defined on non-negative integers.")
            return
        # Base Case: 0! or 1! is 1
        if n &lt;= 1:
            return 1
        # Recursive Step: n * (n-1)!
        return n * self.factorial(n - 1)

def main():
    # Create an instance of the class and call the method
    math_tools = MathTools()
    number = 5
    print(str(number) + "! is " + str(math_tools.factorial(number)))

main()
            </code>
        </program>
        
        <p>
           See if you can spot the differences in the Java version below.
        </p>
        <p>
            Here is the equivalent Java code:
        </p>
        <program interactive="activecode" language="java">
            <code>
public class MathTools {
    public static int factorial(int n) {
        // Check for negative numbers
        if (n &lt; 0) {
            System.out.println("Factorials are only defined on non-negative integers.");
            return -1;  // Return -1 to indicate error
        }
        // Base Case: 0! or 1! is 1
        if (n &lt;= 1) {
            return 1;
        }
        // Recursive Step: n * (n-1)!
        return n * factorial(n - 1);
    }

    public static void main(String[] args) {
        int number = 5;
        System.out.println(number + "! is " + factorial(number));
    }
}
            </code>
        </program>
        <p>
           Notice the key differences from Python: instead of <c>def factorial(n):</c>, Java uses <c>public static int factorial(int n)</c> which declares the method's visibility as <c>public</c>, that it belongs to the class rather than an instance (hence, <c>static</c>), the return type as integer, and the parameter type also as integer. The recursive logic—base case and recursive step—remains identical to Python, but all code blocks use curly braces <c>{}</c> instead of indentation.
        </p>
    </section>

<section xml:id="using-helper-methods">
    <title>Using Helper Methods</title>

    <p>
        In many recursive algorithms, the recursive calls need extra information that the original caller shouldn't have to provide. For example, to recursively process an array, you need to keep track of the current position (index). This extra information clutters the public-facing method signature and forces users to provide implementation details they shouldn't need to know about.
    </p>
    <p><idx>helper method pattern in recursion</idx>
        A common pattern to solve this is using a <term>helper method</term>. This pattern lets you create a clean, simple public method that users will call, while the private helper method handles the complex details of the recursion. The public method typically makes the initial call to the private helper, providing the necessary starting values for the extra parameters.
    </p>
    <p>
        Let's see this pattern in action with an example that calculates the sum of all elements in an integer array. Notice how the public method only requires the array, but the recursive logic needs to track the current index position.
    </p>
    
    <p>
        First, let's see what happens if we try to write a recursive array sum function <em>without</em> using a helper method. In this approach, the user must provide the starting index, which is awkward and exposes implementation details:
    </p>
    <program interactive="activecode" language="python">
        <code>
class ArrayProcessor:
    def sum_array(self, arr, index):
        """
        This version forces users to provide the index parameter.
        This is inconvenient and exposes implementation details.
        """
        # Base case: we've processed all elements
        if index &gt;= len(arr):
            return 0
        
        # Recursive step: current element + sum of remaining elements
        return arr[index] + self.sum_array(arr, index + 1)

def main():
    processor = ArrayProcessor()
    numbers = [1, 2, 3, 4, 5]
    # Users must remember to start at index 0 - this is confusing!
    result = processor.sum_array(numbers, 0)
    print("The sum of " + str(numbers) + " is " + str(result))

main()
        </code>
    </program>
    
    <p>
        This approach has several problems: users must remember to start with index 0, the method signature is cluttered with implementation details, and it's easy to make mistakes by passing the wrong starting index. The same awkward pattern appears in Java:
    </p>
    <program interactive="activecode" language="java">
        <code>
public class ArrayProcessor {
    public static int sumArray(int[] arr, int index) {
        // Base case: we've processed all elements
        if (index &gt;= arr.length) {
            return 0;
        }
        
        // Recursive step: current element + sum of remaining elements
        return arr[index] + sumArray(arr, index + 1);
    }
    
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};
        // Users must remember to start at index 0 - this is confusing!
        int result = sumArray(numbers, 0);
        System.out.println("The sum of [1, 2, 3, 4, 5] is " + result);
    }
}
        </code>
    </program>
    
    <p>
        Both versions force users to understand and provide implementation details they shouldn't need to know about. Now let's see how helper methods solve this problem by providing a clean, user-friendly interface.
    </p>
    
    <p>
        Here's the improved Python version using a helper method:
    </p>
    <program interactive="activecode" language="python">
        <code>
class ArrayProcessor:
    def sum_array(self, arr):
        """
        Public method that provides a clean interface for summing array elements.
        Users only need to provide the array - no implementation details required.
        """
        if not arr:  # Handle empty array
            return 0
        # Start the recursion at index 0
        return self._sum_helper(arr, 0)
    
    def _sum_helper(self, arr, index):
        """
        Private helper method that does the actual recursive work.
        Tracks the current index position through the array.
        """
        # Base case: we've processed all elements
        if index &gt;= len(arr):
            return 0
        
        # Recursive step: current element + sum of remaining elements
        return arr[index] + self._sum_helper(arr, index + 1)

def main():
    processor = ArrayProcessor()
    numbers = [1, 2, 3, 4, 5]
    result = processor.sum_array(numbers)
    print("The sum of " + str(numbers) + " is " + str(result))

main()
        </code>
    </program>
    
    <p><idx>separation of concerns</idx>
        The key insight here is called the <term>separation of concerns</term>. The public <c>sum_array</c> method provides a user-friendly interface—callers just pass an array and get the sum. They don't need to know about indexes or how the recursion works internally. The private <c>_sum_helper</c> method handles the recursive logic with the extra parameter needed to track progress through the array.
    </p>
    
    <p>
        Now let's see the improved Java version using a helper method:
    </p>
    <program interactive="activecode" language="java">
        <code>
public class ArrayProcessor {
    public static int sumArray(int[] arr) {
        // Handle empty array
        if (arr.length == 0) {
            return 0;
        }
        // Start the recursion at index 0
        return sumHelper(arr, 0);
    }
    
    private static int sumHelper(int[] arr, int index) {
        // Base case: we've processed all elements
        if (index &gt;= arr.length) {
            return 0;
        }
        
        // Recursive step: current element + sum of remaining elements
        return arr[index] + sumHelper(arr, index + 1);
    }
    
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};
        int result = sumArray(numbers);
        System.out.println("The sum of [1, 2, 3, 4, 5] is " + result);
    }
}
        </code>
    </program>
    
    <p>
        Compare these improved versions with the earlier problematic ones. Notice how much cleaner the method calls become: <c>processor.sum_array(numbers)</c> in Python and <c>sumArray(numbers)</c> in Java. Users no longer need to worry about providing the correct starting index or understanding the internal mechanics of the recursion. The helper method pattern creates a clear separation between what users need to know (just pass an array) and the implementation details (tracking the index through recursion).
    </p>
    
    <p>
        This helper method pattern is essential when your recursive algorithm needs to track additional state (like array positions, accumulated values, or depth counters) that the original caller shouldn't need to provide. It's a fundamental technique you'll use frequently in recursive problem solving.
    </p>
</section>

    <section xml:id="recursion-limits-in-java">
        <title>Recursion Limits: Python vs. Java</title>
        <p>
            The consequence of deep recursion, running out of stack space, is a concept you've already encountered in Python. Java handles this in a very similar way, throwing an error when the call stack depth is exceeded.
        </p>
        <p>
            The key difference is the name of the error:
        </p>
        <ul>
            <li>In Python, this raises a <c>RecursionError</c>.</li>
            <li>In Java, this throws a <c>StackOverflowError</c>.</li>
        </ul>
        <p>
            Neither language supports <idx> tail call optimization </idx><term>tail call optimization</term>, so the practical limits on recursion depth are a factor in both. If an algorithm requires thousands of recursive calls, an iterative (loop-based) approach is the preferred solution in both Python and Java.
        </p>
        <p>
            The following Python code demonstrates a situation where a function calls itself indefinitely without a base case, leading to aRecursionError.
        </p>
        <program interactive="activecode" language="python">
            <code>
                def cause_recursion_error():
                    """
                    This function calls itself without a base case, guaranteeing an error.
                    """
                    cause_recursion_error()

                # Standard Python entry point
                if __name__ == "__main__":
                    print("Calling the recursive function... this will end in an error!")
                    
                    # This line starts the infinite recursion.
                    # Python will stop it and raise a RecursionError automatically.
                    cause_recursion_error()
            </code>
        </program>

        <p>
            The following Java code demonstrates a similar situation, where a method calls itself indefinitely without a base case, leading to a StackOverflowError.
        </p>
        <program interactive="activecode" language="java">
            <code>
                public class Crash {
                    public static void causeStackOverflow() {
                        // This method calls itself endlessly without a stopping condition (a base case).
                        // Each call adds a new layer to the program's call stack.
                        // Eventually, the stack runs out of space, causing the error.
                        causeStackOverflow();
                    }
                    // A main method is required to run the program.
                    public static void main(String[] args) {
                        System.out.println("Calling the recursive method... this will end in an error!");
                        // This line starts the infinite recursion.
                        causeStackOverflow();
                    }
                }
            </code>
        </program>
    </section>
</chapter>